From 160101ba37f5e6a80b5ca6fea64d6af7e8300fe9 Mon Sep 17 00:00:00 2001
From: Dan Ruelas-Petrisko <petrisko@cs.washington.edu>
Date: Sun, 13 Jul 2025 10:40:28 -0700
Subject: [PATCH] Adding BlackParrot

---
 Makefile                     | 37 ++++++++++++++++++++++++++++++++++++
 src/riscv_asm_program_gen.sv |  9 +++++++--
 src/riscv_instr_pkg.sv       |  2 +-
 3 files changed, 45 insertions(+), 3 deletions(-)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a13b63b
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,37 @@
+
+RISCVDV_TEST_LIST = \
+   riscv_arithmetic_basic_test \
+   riscv_rand_instr_test \
+   riscv_jump_stress_test \
+   riscv_loop_test \
+   riscv_rand_jump_test \
+   riscv_mmu_stress_test \
+   riscv_no_fence_test \
+   riscv_illegal_instr_test \
+   riscv_ebreak_test \
+   riscv_ebreak_debug_mode_test \
+   riscv_full_interrupt_test \
+   riscv_unaligned_load_store_test \
+   riscv_non_compressed_instr_test \
+   riscv_hint_instr_test \
+   riscv_pmp_test \
+   riscv_machine_mode_rand_test \
+   riscv_privileged_mode_rand_test \
+   riscv_invalid_csr_test \
+   riscv_rand_instr_test \
+   riscv_sfence_exception_test \
+   riscv_amo_test \
+   riscv_floating_point_arithmetic_test \
+   riscv_floating_point_rand_test \
+   riscv_floating_point_mmu_stress_test
+   #riscv_csr_test \
+   #riscv_page_table_exception_test \
+
+all: $(addprefix generate., $(RISCVDV_TEST_LIST))
+
+generate.%:
+	$(PYTHON) run.py --target=rv64gc --steps gen,gcc_compile --simulator vcs --iterations 20 --batch_size 5 -o out/ --gcc_opts="$(RISCV_GCC_OPTS)"  -tn $*
+
+clean:
+	rm -rf out*
+	rm -rf ucli*
diff --git a/src/riscv_asm_program_gen.sv b/src/riscv_asm_program_gen.sv
index 4c96924..c121e5b 100644
--- a/src/riscv_asm_program_gen.sv
+++ b/src/riscv_asm_program_gen.sv
@@ -336,22 +336,27 @@ class riscv_asm_program_gen extends uvm_object;
     gen_section("_start", str);
     for (int hart = 0; hart < cfg.num_of_harts; hart++) begin
       instr_stream.push_back($sformatf("%0d: la x%0d, h%0d_start", hart, cfg.scratch_reg, hart));
       instr_stream.push_back($sformatf("jalr x0, x%0d, 0", cfg.scratch_reg));
     end
   endfunction
 
   virtual function void gen_program_end(int hart);
     if (hart == 0) begin
       // Use write_tohost to terminate spike simulation
-      gen_section("write_tohost", {"sw gp, tohost, t5"});
-      gen_section("_exit", {"j write_tohost"});
+      //gen_section("write_tohost", {"sw gp, tohost, t5"});
+      //gen_section("_exit", {"j write_tohost"});
+      gen_section("write_tohost", {"nop"});
+      gen_section("_exit", {"li sp, 0x81000000"});
+      instr_stream.push_back("li a0, 0x00102000");
+      instr_stream.push_back("li a1, 0x0");
+      instr_stream.push_back("sw a1, 0(a0)");
     end
   endfunction
 
   virtual function void gen_data_page_begin(int hart);
     instr_stream.push_back(".section .data");
     if (hart == 0) begin
       instr_stream.push_back(".align 6; .global tohost; tohost: .dword 0;");
       instr_stream.push_back(".align 6; .global fromhost; fromhost: .dword 0;");
     end
   endfunction
diff --git a/src/riscv_instr_pkg.sv b/src/riscv_instr_pkg.sv
index 9620766..e3f0338 100644
--- a/src/riscv_instr_pkg.sv
+++ b/src/riscv_instr_pkg.sv
@@ -1373,21 +1373,21 @@ package riscv_instr_pkg;
   // Push general purpose register to stack, this is needed before trap handling
   function automatic void push_gpr_to_kernel_stack(privileged_reg_t status,
                                                    privileged_reg_t scratch,
                                                    bit mprv,
                                                    riscv_reg_t sp,
                                                    riscv_reg_t tp,
                                                    ref string instr[$]);
     string store_instr = (XLEN == 32) ? "sw" : "sd";
     if (scratch inside {implemented_csr}) begin
       // Push USP from gpr.SP onto the kernel stack
-      instr.push_back($sformatf("addi x%0d, x%0d, -4", tp, tp));
+      instr.push_back($sformatf("addi x%0d, x%0d, %d", tp, tp, -(XLEN/8)));
       instr.push_back($sformatf("%0s  x%0d, (x%0d)", store_instr, sp, tp));
       // Move KSP to gpr.SP
       instr.push_back($sformatf("add x%0d, x%0d, zero", sp, tp));
     end
     // If MPRV is set and MPP is S/U mode, it means the address translation and memory protection
     // for load/store instruction is the same as the mode indicated by MPP. In this case, we
     // need to use the virtual address to access the kernel stack.
     if((status == MSTATUS) && (SATP_MODE != BARE)) begin
       // We temporarily use tp to check mstatus to avoid changing other GPR.
       // (The value of sp has been pushed to the kernel stack, so can be recovered later)
-- 
2.18.4

