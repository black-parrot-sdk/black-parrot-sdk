From 66a326a7d0e848792c9528b979ea1b61f96ef49d Mon Sep 17 00:00:00 2001
From: Dan Ruelas-Petrisko <petrisko@cs.washington.edu>
Date: Sat, 19 Jul 2025 17:34:03 -0700
Subject: [PATCH] Adding BP host

---
 CMakeLists.txt             |   4 +
 include/dromajo_cosim.h    |   4 +-
 include/dromajo_template.h |   4 +
 include/iomem.h            |  13 ++-
 include/machine.h          |   5 +
 include/riscv_cpu.h        |   7 +-
 include/riscv_machine.h    |  27 ++++-
 src/dromajo.cpp            |  44 ++++++--
 src/dromajo_cosim.cpp      |  61 ++++++-----
 src/dromajo_cosim_test.cpp |   4 +-
 src/dromajo_main.cpp       |  21 ++++
 src/iomem.cpp              |  12 ++-
 src/pci.cpp                |   4 +-
 src/riscv_cpu.cpp          |  85 +++++++++------
 src/riscv_machine.cpp      | 215 ++++++++++++++++++++++++++++++++++---
 src/virtio.cpp             |   4 +
 16 files changed, 416 insertions(+), 98 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e2cd7e2..0a87335 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -79,20 +79,24 @@ if (TRACEOS)
             -DDUMP_ILLEGAL_INSTRUCTIONS
     )
 endif ()
 
 if (SIMPOINT)
     add_compile_options(
             -DSIMPOINT_BB
     )
 endif ()
 
+add_link_options(
+    -pthread
+)
+
 # Set Version Header
 set(CONFIG_VERSION "Dromajo-0.1")
 configure_file(include/config.h.in config.h @ONLY)
 
 if (WARMUP)
   message(STATUS "Checkpoint with WARMUP is on (typically for simpoints, but any checkpoint can use it).")
     add_compile_options( -DLIVECACHE)
 endif ()
 
 if (GOLDMEM)
diff --git a/include/dromajo_cosim.h b/include/dromajo_cosim.h
index effdfab..8df2e47 100644
--- a/include/dromajo_cosim.h
+++ b/include/dromajo_cosim.h
@@ -52,30 +52,30 @@ void dromajo_cosim_fini(dromajo_cosim_state_t *state);
  * being the upper bits (ie., all but LSB).  Caveat: the DUT is
  * assumed to provide the instructions bit after expansion, so this is
  * only matched on non-compressed instruction.
  *
  * There are a number of situations where the model cannot match the
  * DUT, such as loads from IO devices, interrupts, and CSRs cycle,
  * time, and instret.  For all these cases the model will override
  * with the expected values.
  */
 int dromajo_cosim_step(dromajo_cosim_state_t *state, int hartid, uint64_t dut_pc, uint32_t dut_insn, uint64_t dut_wdata,
-                       uint64_t mstatus, bool check);
+                       uint64_t mstatus, bool check, bool verbose);
 
 /*
  * dromajo_cosim_raise_trap --
  *
  * DUT raises a trap (exception or interrupt) and provides the cause.
  * MSB indicates an asynchronous interrupt, synchronous exception
  * otherwise.
  */
-void dromajo_cosim_raise_trap(dromajo_cosim_state_t *state, int hartid, int64_t cause);
+void dromajo_cosim_raise_trap(dromajo_cosim_state_t *state, int hartid, int64_t cause, bool verbose);
 
 /*
  * dromajo_cosim_override_mem --
  *
  * DUT sets Dromajo memory. Used so that other devices (i.e. block device, accelerators, can write to memory).
  */
 int dromajo_cosim_override_mem(dromajo_cosim_state_t *state, int hartid, uint64_t dut_paddr, uint64_t dut_val, int size_log2);
 
 /*
  * dromajo_install_new_loggers --
diff --git a/include/dromajo_template.h b/include/dromajo_template.h
index 44504aa..e90a1dd 100644
--- a/include/dromajo_template.h
+++ b/include/dromajo_template.h
@@ -1294,20 +1294,24 @@ int no_inline glue(riscv_cpu_interp, XLEN)(RISCVCPUState *s, int n_cycles) {
         uint##size##_t rval;                                                               \
                                                                                            \
         addr   = read_reg(rs1);                                                            \
         funct3 = insn >> 27;                                                               \
         switch (funct3) {                                                                  \
             case 2: /* lr.w/lr.d */                                                        \
                 if (rs2 != 0)                                                              \
                     goto illegal_insn;                                                     \
                 if (target_read_u##size(s, &rval, addr))                                   \
                     goto mmu_exception;                                                    \
+                /* Clobber other CPUs reservations */                                      \
+                for(int i=0; i < s->machine->ncpus; i++)                                   \
+                    if(s->machine->cpu_state[i]->load_res == addr)                         \
+                        s->machine->cpu_state[i]->load_res = ~0;                           \
                 val                  = (int##size##_t)rval;                                \
                 s->load_res          = addr;                                               \
                 s->load_res_memseqno = s->machine->memseqno;                               \
                 break;                                                                     \
                                                                                            \
             case 3: /* sc.w/sc.d */                                                        \
                 if ((addr & (size / 8 - 1)) != 0) {                                        \
                     s->pending_tval      = addr;                                           \
                     s->pending_exception = CAUSE_MISALIGNED_STORE;                         \
                     goto mmu_exception;                                                    \
diff --git a/include/iomem.h b/include/iomem.h
index 31d63c5..1f379c4 100644
--- a/include/iomem.h
+++ b/include/iomem.h
@@ -35,55 +35,64 @@
  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
 #ifndef IOMEM_H
 #define IOMEM_H
 
 #include "cutils.h"
 
+typedef void     DeviceInitFunc(void *opaque);
 typedef void     DeviceWriteFunc(void *opaque, uint32_t offset, uint32_t val, int size_log2);
 typedef uint32_t DeviceReadFunc(void *opaque, uint32_t offset, int size_log2);
+typedef void     DeviceTickFunc(void *opaque, int n_cycles);
 
 #define DEVIO_SIZE8  (1 << 0)
 #define DEVIO_SIZE16 (1 << 1)
 #define DEVIO_SIZE32 (1 << 2)
 /* not supported, could add specific 64 bit callbacks when needed */
 //#define DEVIO_SIZE64 (1 << 3)
 #define DEVIO_DISABLED (1 << 4)
 
 #define DEVRAM_FLAG_ROM        (1 << 0) /* not writable */
 #define DEVRAM_FLAG_DIRTY_BITS (1 << 1) /* maintain dirty bits */
 #define DEVRAM_FLAG_DISABLED   (1 << 2) /* allocated but not mapped */
 #define DEVRAM_PAGE_SIZE_LOG2  12
 #define DEVRAM_PAGE_SIZE       (1 << DEVRAM_PAGE_SIZE_LOG2)
 
 typedef struct PhysMemoryMap PhysMemoryMap;
 
+void     DefaultInitFunc(void *opaque);
+void     DefaultWriteFunc(void *opaque, uint32_t offset, uint32_t val, int size_log2);
+uint32_t DefaultReadFunc(void *opaque, uint32_t offset, int size_log2);
+void     DefaultTickFunc(void *opaque, int n_cycles);
+
 typedef struct {
     PhysMemoryMap *map;
     uint64_t       addr;
     uint64_t       org_size; /* original size */
     uint64_t       size;     /* =org_size or 0 if the mapping is disabled */
     BOOL           is_ram;
     /* the following is used for RAM access */
     int       devram_flags;
     uint8_t * phys_mem;
     int       dirty_bits_size; /* in bytes */
     uint32_t *dirty_bits;      /* NULL if not used */
     uint32_t *dirty_bits_tab[2];
     int       dirty_bits_index; /* 0-1 */
     /* the following is used for I/O access */
     void *           opaque;
+    DeviceInitFunc * init_func;
     DeviceReadFunc * read_func;
     DeviceWriteFunc *write_func;
+    DeviceTickFunc * tick_func;
     int              devio_flags;
 } PhysMemoryRange;
 
 #define PHYS_MEM_RANGE_MAX 32
 
 struct PhysMemoryMap {
     int             n_phys_mem_range;
     PhysMemoryRange phys_mem_range[PHYS_MEM_RANGE_MAX];
     PhysMemoryRange *(*register_ram)(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags);
     void (*free_ram)(PhysMemoryMap *s, PhysMemoryRange *pr);
@@ -92,22 +101,22 @@ struct PhysMemoryMap {
     void *opaque;
     void (*flush_tlb_write_range)(void *opaque, uint8_t *ram_addr, size_t ram_size);
 };
 
 PhysMemoryMap *                phys_mem_map_init(void);
 void                           phys_mem_map_end(PhysMemoryMap *s);
 PhysMemoryRange *              register_ram_entry(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags);
 static inline PhysMemoryRange *cpu_register_ram(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags) {
     return s->register_ram(s, addr, size, devram_flags);
 }
-PhysMemoryRange *cpu_register_device(PhysMemoryMap *s, uint64_t addr, uint64_t size, void *opaque, DeviceReadFunc *read_func,
-                                     DeviceWriteFunc *write_func, int devio_flags);
+PhysMemoryRange *cpu_register_device(PhysMemoryMap *s, uint64_t addr, uint64_t size, void *opaque, DeviceInitFunc *init_func, DeviceReadFunc *read_func,
+                                     DeviceWriteFunc *write_func, DeviceTickFunc *tick_func, int devio_flags);
 PhysMemoryRange *get_phys_mem_range(PhysMemoryMap *s, uint64_t paddr);
 void             phys_mem_set_addr(PhysMemoryRange *pr, uint64_t addr, BOOL enabled);
 
 static inline const uint32_t *phys_mem_get_dirty_bits(PhysMemoryRange *pr) {
     PhysMemoryMap *map = pr->map;
     return map->get_dirty_bits(map, pr);
 }
 
 static inline void phys_mem_set_dirty_bit(PhysMemoryRange *pr, size_t offset) {
     size_t   page_index;
diff --git a/include/machine.h b/include/machine.h
index 3f84954..6698861 100644
--- a/include/machine.h
+++ b/include/machine.h
@@ -169,20 +169,23 @@ typedef struct {
 
     /* PLIC/CLINT Params */
     uint64_t plic_base_addr;
     uint64_t plic_size;
     uint64_t clint_base_addr;
     uint64_t clint_size;
 
     /* Add to misa custom extensions */
     bool custom_extension;
 
+    /* Periodically create checkpoints */
+    uint64_t checkpoint;
+
     /* Clear mimpid, marchid, mvendorid */
     bool clear_ids;
 
     uint64_t physical_addr_len;
 
     char *logfile;  // If non-zero, all output goes here, stderr and stdout
 
     bool dump_memories;
 } VirtMachineParams;
 
@@ -198,20 +201,21 @@ typedef struct VirtMachine {
 #ifdef SIMPOINT_BB
     uint32_t              simpoint_next;
     std::vector<Simpoint> simpoints;
 #endif
 
     char *   snapshot_load_name;
     char *   snapshot_save_name;
     char *   terminate_event;
     uint64_t maxinsns;
     uint64_t trace;
+    uint64_t checkpoint;
 
     /* For co-simulation only, they are -1 if nothing is pending. */
     bool cosim;
     int  pending_interrupt;
     int  pending_exception;
 
     /* Central logging facility, so far only used in dromajo_cosim */
     dromajo_logging_func_t *error_log;
     dromajo_logging_func_t *debug_log;
 } VirtMachine;
@@ -254,15 +258,16 @@ BlockDevice *block_device_init_http(const char *url, int max_cache_size_kb, void
 extern "C" {
 #endif
 RISCVMachine *virt_machine_main(int argc, char **argv);
 void          virt_machine_end(RISCVMachine *s);
 void          virt_machine_serialize(RISCVMachine *m, const char *dump_name);
 void          virt_machine_deserialize(RISCVMachine *m, const char *dump_name);
 BOOL          virt_machine_run(RISCVMachine *m, int hartid, int n_cycles);
 uint64_t      virt_machine_get_pc(RISCVMachine *m, int hartid);
 uint64_t      virt_machine_get_reg(RISCVMachine *m, int hartid, int rn);
 uint64_t      virt_machine_get_fpreg(RISCVMachine *m, int hartid, int rn);
+void          virt_machine_tick(RISCVMachine *m, int n_cycles);
 #ifdef __cplusplus
 }  // extern C
 #endif
 
 #endif
diff --git a/include/riscv_cpu.h b/include/riscv_cpu.h
index f11fbde..04505d5 100644
--- a/include/riscv_cpu.h
+++ b/include/riscv_cpu.h
@@ -99,21 +99,21 @@ typedef uint128_t fp_uint;
 /* VLEN is the vector register width */
 #define IS_PO2(n)    ((n) && ((n) & ((n)-1)) == 0)
 #define ELEN_MIN     (1 << 3)
 #define VLEN_MAX     (1 << 16)
 #define ELEN_DEFAULT (1 << 6)
 #define VLEN_DEFAULT (1 << 7)
 /* Modify these lines to fit architectural params */
 //#define VLEN <size_in_bits_here>
 //#define ELEN <typically_default_but_might_be_rattified>
 /* Uncomment the next line to DISABLE Vector Simulation "V-extension" */
-//#define VLEN 0
+#define VLEN 0
 /* Uncomment the next line to have masked elements under mask-agnotic policy be filled with 1's
  * useful for vector register renaming, where masked elements dont need to be copied */
 //#define MASK_AGNOSTIC_FILL 1
 #ifndef VLEN
 #define VLEN VLEN_DEFAULT
 #endif
 #ifndef ELEN
 #define ELEN ELEN_DEFAULT
 #endif
 #if (ELEN < ELEN_MIN || VLEN < ELEN || !IS_PO2(ELEN))
@@ -233,20 +233,21 @@ typedef struct RISCVCPUState {
     uint64_t minstret;      // RISCV CSR (updated when insn_counter increases)
     uint64_t mcycle;        // RISCV CSR (updated when insn_counter increases)
     BOOL     debug_mode;
     BOOL     stop_the_counter;  // Set in debug mode only (cleared after ending Debug)
 
     BOOL power_down_flag; /* True when the core is idle awaiting
                            * interrupts, does NOT mean terminate
                            * simulation */
     BOOL         terminate_simulation;
     int          pending_exception; /* used during MMU exception handling */
+    int          pending_interrupt;
     target_ulong pending_tval;
 
     /* CSRs */
     target_ulong mstatus;
     target_ulong mtvec;
     target_ulong mscratch;
     target_ulong mepc;
     target_ulong mcause;
     target_ulong mtval;
     target_ulong mvendorid; /* ro */
@@ -362,20 +363,24 @@ void riscv_set_debug_mode(RISCVCPUState *s, bool on);
 
 int riscv_benchmark_exit_code(RISCVCPUState *s);
 
 #include "riscv_machine.h"
 void riscv_cpu_serialize(RISCVCPUState *s, const char *dump_name, const uint64_t clint_base_addr);
 void riscv_cpu_deserialize(RISCVCPUState *s, const char *dump_name);
 
 int riscv_cpu_read_memory(RISCVCPUState *s, mem_uint_t *pval, target_ulong addr, int size_log2);
 int riscv_cpu_write_memory(RISCVCPUState *s, target_ulong addr, mem_uint_t val, int size_log2);
 
+void serialize_memory(const void *base, size_t size, const char *file);
+void deserialize_memory(void *base, size_t size, const char *file);
+void create_boot_rom(RISCVMachine *m, const char *file, const uint64_t clint_base_addr);
+
 #define PHYS_MEM_READ_WRITE(size, uint_type)                                              \
     void      riscv_phys_write_u##size(RISCVCPUState *, target_ulong, uint_type, bool *); \
     uint_type riscv_phys_read_u##size(RISCVCPUState *, target_ulong, bool *);
 
 PHYS_MEM_READ_WRITE(8, uint8_t)
 PHYS_MEM_READ_WRITE(32, uint32_t)
 PHYS_MEM_READ_WRITE(64, uint64_t)
 
 #undef PHYS_MEM_READ_WRITE
 
diff --git a/include/riscv_machine.h b/include/riscv_machine.h
index 7e5ffaa..75bcc30 100644
--- a/include/riscv_machine.h
+++ b/include/riscv_machine.h
@@ -41,21 +41,21 @@
 #define RISCV_MACHINE_H
 
 #include "machine.h"
 #include "riscv_cpu.h"
 #include "virtio.h"
 
 #ifdef LIVECACHE
 #include "LiveCacheCore.h"
 #endif
 
-#define MAX_CPUS 8
+#define MAX_CPUS 32
 #define MAX_VIOS MAX_ETH_DEVICE + MAX_DRIVE_DEVICE + 3
 
 /* Hooks */
 typedef struct RISCVMachineHooks {
     /* Returns -1 if invalid CSR, 0 if OK. */
     int (*csr_read)(RISCVCPUState *s, uint32_t funct3, uint32_t csr, uint64_t *pval);
     int (*csr_write)(RISCVCPUState *s, uint32_t funct3, uint32_t csr, uint64_t val);
 } RISCVMachineHooks;
 
 struct RISCVMachine {
@@ -100,36 +100,59 @@ struct RISCVMachine {
     bool bootrom_loaded;
 
     /* PLIC/CLINT Params */
     uint64_t plic_base_addr;
     uint64_t plic_size;
     uint64_t clint_base_addr;
     uint64_t clint_size;
 
     uint64_t initrd_start;
 
+    /* Whether to keep running the simulation globally */
+    bool keep_going;
+
+    /* running total of instructions */
+    uint64_t totalinsns;
+
     /* Append to misa custom extensions */
     bool custom_extension;
 
     /* Clear mimpid, marchid, mvendorid */
     bool clear_ids;
 
     /* Extension state, not used by Dromajo itself */
     void *ext_state;
 };
 
 #define PLIC_BASE_ADDR 0x10000000
 #define PLIC_SIZE      0x2000000
 
-#define CLINT_BASE_ADDR 0x02000000
+#define CORE_SHIFT      24
+#define CLINT_BASE_ADDR 0x00300000
 #define CLINT_SIZE      0x000c0000
 
+// These must be kept up to date with the RTL code and SDK aviary.h
+#define PARAM_ROM_BASE_ADDR 0x120000
+#define PARAM_ROM_SIZE 0x012C
+#define PARAM_CC_X_DIM 0x0000
+#define PARAM_CC_Y_DIM 0x0004
+
+#define HOST_MASK      0xf000
+#define HOST_BASE_ADDR 0x00100000
+#define HOST_SIZE      0x00100000
+#define HOST_GETCHAR   0x0000
+#define HOST_PUTCHAR   0x1000
+#define HOST_FINISH    0x2000
+#define HOST_GPUTCHAR  0x3000
+#define HOST_SIG       0x4000
+#define HOST_PUTINT    0x5000
+
 // CPU_FREQUENCY is a u32, so less than 4GHz
 #define CPU_FREQUENCY 18000000
 #define RTC_FREQ       1000000
 
 #define RTC_FREQ_DIV (CPU_FREQUENCY / RTC_FREQ)
 
 #define HTIF_BASE_ADDR        0x40008000
 #define IDE_BASE_ADDR         0x40009000
 #define VIRTIO_BASE_ADDR      0x40010000
 #define VIRTIO_SIZE           0x1000
diff --git a/src/dromajo.cpp b/src/dromajo.cpp
index f283864..2a141a9 100644
--- a/src/dromajo.cpp
+++ b/src/dromajo.cpp
@@ -116,36 +116,62 @@ int simpoint_step(RISCVMachine *m, int hartid) {
         ninst = 0;
     }
     last_pc = pc;
 
     return 1;
 }
 #endif
 
 static int iterate_core(RISCVMachine *m, int hartid, int n_cycles) {
     m->common.maxinsns -= n_cycles;
+    m->totalinsns += n_cycles;
 
     if (m->common.maxinsns <= 0)
         /* Succeed after N instructions without failure. */
         return 0;
 
     RISCVCPUState *cpu = m->cpu_state[hartid];
 
     /* Instruction that raises exceptions should be marked as such in
      * the trace of retired instructions.
      */
     uint64_t last_pc  = virt_machine_get_pc(m, hartid);
     int      priv     = riscv_get_priv_level(cpu);
     uint32_t insn_raw = -1;
     bool     do_trace = false;
 
     (void)riscv_read_insn(cpu, &insn_raw, last_pc);
+
+    if (insn_raw == 0x7b200073) { // dret
+        m->totalinsns = 0;
+    }
+
+    if (!cpu->debug_mode && m->common.snapshot_save_name) {
+        uint64_t period = m->common.checkpoint;
+        uint64_t newinsns = m->totalinsns;
+        uint64_t prvinsns = m->totalinsns - n_cycles;
+
+        if (cpu->pc == m->ram_base_addr) {
+            std::string name = std::string(m->common.snapshot_save_name);
+            name += ".init";
+            virt_machine_serialize(m, name.c_str());
+        }
+
+        if (period && (prvinsns / period) < (newinsns / period)) {
+            std::string name = std::string(m->common.snapshot_save_name);
+            name += '.' + std::to_string(prvinsns);
+            virt_machine_serialize(m, name.c_str());
+        }
+    }
+
+    virt_machine_tick(m, n_cycles);
+
     if (m->common.trace < (unsigned)n_cycles) {
         n_cycles = 1;
         do_trace = true;
     } else
         m->common.trace -= n_cycles;
 
     int keep_going = virt_machine_run(m, hartid, n_cycles);
 
     if (!do_trace) {
         return keep_going;
@@ -163,43 +189,47 @@ static int iterate_core(RISCVMachine *m, int hartid, int n_cycles) {
 
     if (cpu->pending_exception != -1)
         fprintf(dromajo_stderr,
                 " exception %d, tval %016" PRIx64,
                 cpu->pending_exception,
                 riscv_get_priv_level(cpu) == PRV_M ? cpu->mtval : cpu->stval);
     else if (iregno > 0)
         fprintf(dromajo_stderr, " x%2d 0x%016" PRIx64, iregno, virt_machine_get_reg(m, hartid, iregno));
     else if (fregno >= 0)
         fprintf(dromajo_stderr, " f%2d 0x%016" PRIx64, fregno, virt_machine_get_fpreg(m, hartid, fregno));
+#if VLEN > 0
     else
         for (int i = 31; i >= 0; i--)
             if (cpu->most_recently_written_vregs[i]) {
                 fprintf(dromajo_stderr, " v%2d 0x", i);
                 for (int j = VLEN / 8 - 1; j >= 0; j--) {
                     fprintf(dromajo_stderr, "%02" PRIx8, cpu->v_reg[i][j]);
                 }
             }
+#endif
 
     putc('\n', dromajo_stderr);
 
     return keep_going;
 }
 
 static double    execution_start_ts;
 static uint64_t *execution_progress_meassure;
 
-static void sigintr_handler(int dummy) {
-    double t = get_current_time_in_seconds();
-    fprintf(dromajo_stderr,
-            "Simulation speed: %5.2f MIPS (single-core)\n",
-            1e-6 * *execution_progress_meassure / (t - execution_start_ts));
-    exit(1);
+// from riscv-isa-sim
+volatile bool ctrlc_pressed = false;
+static void sigintr_handler(int sig)
+{
+    if (ctrlc_pressed)
+        exit(-1);
+    ctrlc_pressed = true;
+    signal(sig, &sigintr_handler);
 }
 
 int main(int argc, char **argv) {
 #ifdef REGRESS_COSIM
     dromajo_cosim_state_t *costate = 0;
     costate                        = dromajo_cosim_init(argc, argv);
 
     if (!costate)
         return 1;
 
@@ -230,21 +260,21 @@ int main(int argc, char **argv) {
     int keep_going;
     do {
         keep_going = 0;
         for (int i = 0; i < m->ncpus; ++i) keep_going |= iterate_core(m, i, n_cycles);
 #ifdef SIMPOINT_BB
         if (simpoint_roi) {
             if (!simpoint_step(m, 0))
                 break;
         }
 #endif
-    } while (keep_going);
+    } while (keep_going && m->keep_going);
 
     double t = get_current_time_in_seconds();
 
     for (int i = 0; i < m->ncpus; ++i) {
         int benchmark_exit_code = riscv_benchmark_exit_code(m->cpu_state[i]);
         if (benchmark_exit_code != 0) {
             fprintf(dromajo_stderr, "\nBenchmark exited with code: %i \n", benchmark_exit_code);
             return 1;
         }
     }
diff --git a/src/dromajo_cosim.cpp b/src/dromajo_cosim.cpp
index 00c4743..27f18cc 100644
--- a/src/dromajo_cosim.cpp
+++ b/src/dromajo_cosim.cpp
@@ -41,22 +41,24 @@ void check_inorder_init(int ncores);
  * Returns NULL upon failure.
  */
 dromajo_cosim_state_t *dromajo_cosim_init(int argc, char *argv[]) {
     RISCVMachine *m = virt_machine_main(argc, argv);
 
 #ifdef GOLDMEM_INORDER
     check_inorder_init(m->ncpus);
 #endif
 
     m->common.cosim             = true;
-    m->common.pending_interrupt = -1;
-    m->common.pending_exception = -1;
+    for (int i = 0; i < m->ncpus; i++) {
+        m->cpu_state[i]->pending_interrupt = -1;
+        m->cpu_state[i]->pending_exception = -1;
+    }
 
     return (dromajo_cosim_state_t *)m;
 }
 
 void dromajo_cosim_fini(dromajo_cosim_state_t *state) { virt_machine_end((RISCVMachine *)state); }
 
 static bool is_store_conditional(uint32_t insn) {
     int opcode = insn & 0x7f, funct3 = insn >> 12 & 7;
     return opcode == 0x2f && insn >> 27 == 3 && (funct3 == 2 || funct3 == 3);
 }
@@ -156,21 +158,21 @@ static inline void handle_dut_overrides(RISCVCPUState *s, int priv, uint64_t pc,
     }
 }
 
 /*
  * dromajo_cosim_raise_trap --
  *
  * DUT raises a trap (exception or interrupt) and provides the cause.
  * MSB indicates an asynchronous interrupt, synchronous exception
  * otherwise.
  */
-void dromajo_cosim_raise_trap(dromajo_cosim_state_t *state, int hartid, int64_t cause) {
+void dromajo_cosim_raise_trap(dromajo_cosim_state_t *state, int hartid, int64_t cause, bool verbose) {
     VirtMachine *m = (VirtMachine *)state;
 
     if (cause < 0) {
         assert(m->pending_interrupt == -1);
         m->pending_interrupt = cause & 63;
         (m->debug_log)(hartid, "[DEBUG] DUT raised interrupt %d\n", m->pending_interrupt);
     } else {
         m->pending_exception = cause;
         (m->debug_log)(hartid, "[DEBUG] DUT raised exception %d\n", m->pending_exception);
     }
@@ -185,31 +187,30 @@ void dromajo_cosim_raise_trap(dromajo_cosim_state_t *state, int hartid, int64_t
  * being the upper bits (ie., all but LSB).  Caveat: the DUT provides
  * the instructions bit after expansion, so this is only matched on
  * non-compressed instruction.
  *
  * There are a number of situations where the model cannot match the
  * DUT, such as loads from IO devices, interrupts, and CSRs cycle,
  * time, and instret.  For all these cases the model will override
  * with the expected values.
  */
 int dromajo_cosim_step(dromajo_cosim_state_t *state, int hartid, uint64_t dut_pc, uint32_t dut_insn, uint64_t dut_wdata,
-                       uint64_t dut_mstatus, bool check) {
+                       uint64_t dut_mstatus, bool check, bool verbose) {
     RISCVMachine *r = (RISCVMachine *)state;
     assert(r->ncpus > hartid);
     RISCVCPUState *s = r->cpu_state[hartid];
     VirtMachine    m = r->common;
     uint64_t       emu_pc, emu_wdata = 0;
     int            emu_priv;
     uint32_t       emu_insn;
     bool           emu_wrote_data = false;
     int            exit_code      = 0;
-    bool           verbose        = true;
     int            iregno, fregno;
     char           log_buffer[512];
     int            log_buff_space;
 
     /* Succeed after N instructions without failure. */
     if (r->common.maxinsns == 0) {
         return 1;
     }
 
     r->common.maxinsns--;
@@ -219,88 +220,90 @@ int dromajo_cosim_step(dromajo_cosim_state_t *state, int hartid, uint64_t dut_pc
     }
 
     /*
      * Execute one instruction in the simulator.  Because exceptions
      * may fire, the current instruction may not be executed, thus we
      * have to iterate until one does.
      */
     iregno = -1;
     fregno = -1;
 
+    // DWP: Do not check in debug mode
+    while (s->debug_mode) riscv_cpu_interp64(s, 1);
+
     for (;;) {
         emu_priv = riscv_get_priv_level(s);
         emu_pc   = riscv_get_pc(s);
         riscv_read_insn(s, &emu_insn, emu_pc);
 
         if ((emu_insn & 3) != 3)
             emu_insn &= 0xFFFF;
 
-        if (emu_pc == dut_pc && emu_insn == dut_insn && is_store_conditional(emu_insn) && dut_wdata != 0) {
-            /* When DUT fails an SC, we must simulate the same behavior */
-            iregno = emu_insn >> 7 & 0x1f;
-            if (iregno > 0)
-                riscv_set_reg(s, iregno, dut_wdata);
-            riscv_set_pc(s, emu_pc + 4);
-            break;
-        }
-
-        if (r->common.pending_interrupt != -1 && r->common.pending_exception != -1) {
+        if (r->cpu_state[hartid]->pending_interrupt != -1 && r->cpu_state[hartid]->pending_exception !=
+ -1) {
             /* On the DUT, the interrupt can race the exception.
                Let's try to match that behavior */
 
-            (m.debug_log)(hartid, "[DEBUG] DUT also raised exception %d\n", r->common.pending_exception);
+            (m.debug_log)(hartid, "[DEBUG] DUT also raised exception %d\n", r->cpu_state[hartid]->pending_exception);
             riscv_cpu_interp64(s, 1);  // Advance into the exception
 
             int cause = s->priv == PRV_S ? s->scause : s->mcause;
 
-            if (r->common.pending_exception != cause) {
+            if (r->cpu_state[hartid]->pending_exception != cause) {
                 char priv = s->priv["US?M"];
 
                 /* Unfortunately, handling the error case is awkward,
                  * so we just exit from here */
 
                 log_buff_space = snprintf(log_buffer, 512, "%d 0x%016" PRIx64 " ", emu_priv, emu_pc);
                 log_buff_space += snprintf(log_buffer + log_buff_space, 512 - log_buff_space, " (0x%08x) ", emu_insn);
                 log_buff_space += snprintf(log_buffer + log_buff_space,
                                            512 - log_buff_space,
                                            "[error] EMU %cCAUSE %d != DUT %cCAUSE %d\n",
                                            priv,
                                            cause,
                                            priv,
-                                           r->common.pending_exception);
+                                           r->cpu_state[hartid]->pending_exception);
                 (m.error_log)(hartid, log_buffer);
 
                 return 0x1FFF;
             }
         }
 
-        if (r->common.pending_interrupt != -1) {
-            riscv_cpu_set_mip(s, riscv_cpu_get_mip(s) | 1 << r->common.pending_interrupt);
+        if (r->cpu_state[hartid]->pending_interrupt != -1) {
+            riscv_cpu_set_mip(s, riscv_cpu_get_mip(s) | 1 << r->cpu_state[hartid]->pending_interrupt);
             (m.debug_log)(hartid,
                           "[DEBUG] Interrupt: MIP <- %d: Now MIP = %x\n",
-                          r->common.pending_interrupt,
+                          r->cpu_state[hartid]->pending_interrupt,
                           riscv_cpu_get_mip(s));
         }
 
+        if (is_store_conditional(emu_insn) && dut_wdata != 0) {
+            /* When DUT fails an SC, we must simulate the same behavior */
+            s->load_res = ~0;
+            s->load_res_memseqno = 0;
+        } else if (is_store_conditional(emu_insn) && dut_wdata == 0) {
+            /* Similarly, when DUT succeeds... */
+            int rs1 = (emu_insn >> 15) & 0x1f;
+            s->load_res = riscv_get_reg(s, rs1);
+            s->load_res_memseqno = s->machine->memseqno;
+        }
+
         if (riscv_cpu_interp64(s, 1) != 0) {
             iregno = riscv_get_most_recently_written_reg(s);
             fregno = riscv_get_most_recently_written_fp_reg(s);
 
-            //// ABE: I think this is the solution
-            // r->common.pending_interrupt = -1;
-            // r->common.pending_exception = -1;
-
             break;
         }
 
-        r->common.pending_interrupt = -1;
-        r->common.pending_exception = -1;
+        r->cpu_state[hartid]->pending_interrupt = -1;
+        r->cpu_state[hartid]->pending_exception = -1;
     }
 
 #ifdef GOLDMEM_INORDER
     bool do_clw = (dut_insn & 0x3) == 0 && (dut_insn & 0xe000) == 0x4000;
     bool do_cld = (dut_insn & 0x3) == 0 && (dut_insn & 0xe000) == 0x6000;
     bool do_csw = (dut_insn & 0x3) == 0 && (dut_insn & 0xe000) == 0xC000;
     bool do_csd = (dut_insn & 0x3) == 0 && (dut_insn & 0xe000) == 0xe000;
 
     bool do_clwsp = (dut_insn & 0x3) == 2 && (dut_insn & 0xe000) == 0x4000;
     bool do_cldsp = (dut_insn & 0x3) == 2 && (dut_insn & 0xe000) == 0x6000;
@@ -440,22 +443,22 @@ int dromajo_cosim_step(dromajo_cosim_state_t *state, int hartid, uint64_t dut_pc
      */
     if (emu_pc != dut_pc || emu_insn != dut_insn && (emu_insn & 3) == 3 ||  // DUT expands all C instructions
         emu_wdata != dut_wdata && emu_wrote_data) {
         (m.error_log)(hartid, "[error] EMU PC %016" PRIx64 ", DUT PC %016" PRIx64 "\n", emu_pc, dut_pc);
         (m.error_log)(hartid, "[error] EMU INSN %08x, DUT INSN %08x\n", emu_insn, dut_insn);
         if (emu_wrote_data)
             (m.error_log)(hartid, "[error] EMU WDATA %016" PRIx64 ", DUT WDATA %016" PRIx64 "\n", emu_wdata, dut_wdata);
         (m.error_log)(hartid, "[error] EMU MSTATUS %08" PRIx64 ", DUT MSTATUS %08" PRIx64 "\n", emu_mstatus, dut_mstatus);
         (m.error_log)(hartid,
                       "[error] DUT pending exception %d pending interrupt %d\n",
-                      r->common.pending_exception,
-                      r->common.pending_interrupt);
+                      r->cpu_state[hartid]->pending_exception,
+                      r->cpu_state[hartid]->pending_interrupt);
         exit_code = 0x1FFF;
     }
 
     riscv_cpu_sync_regs(s);
 
     if (exit_code == 0)
         riscv_cpu_sync_regs(s);
 
     return exit_code;
 }
diff --git a/src/dromajo_cosim_test.cpp b/src/dromajo_cosim_test.cpp
index 56103b7..9b947a3 100644
--- a/src/dromajo_cosim_test.cpp
+++ b/src/dromajo_cosim_test.cpp
@@ -135,25 +135,25 @@ int main(int argc, char *argv[]) {
             default: fprintf(dromajo_stderr, "%s:%d: couldn't parse %s\n", trace_name, lineno, buf); goto fail;
 
             case 0:
             case -1: continue;
         }
 
         if (!cosim)
             continue;
 
         if (exception && (exception < 8 || exception > 11)) {  // do not skip ECALLS
-            dromajo_cosim_raise_trap(s, hartid, exception);
+            dromajo_cosim_raise_trap(s, hartid, exception, true);
             fprintf(dromajo_stdout, "exception %d with tval %08" PRIx64 "\n", exception, tval);
             continue;
         }
-        int r = dromajo_cosim_step(s, hartid, insn_addr, insn, wdata, 0, true);
+        int r = dromajo_cosim_step(s, hartid, insn_addr, insn, wdata, 0, true, false);
         if (r) {
             fprintf(dromajo_stdout, "Exited with %08x\n", r);
             goto fail;
         }
     }
 
 done:
     if (cosim)
         dromajo_cosim_fini(s);
 
diff --git a/src/dromajo_main.cpp b/src/dromajo_main.cpp
index 731ed28..5717385 100644
--- a/src/dromajo_main.cpp
+++ b/src/dromajo_main.cpp
@@ -572,20 +572,21 @@ static void usage(const char *prog, const char *msg) {
             "       --dump_memories dump memories that could be used to load a cosimulation\n"
             "       --memory_size sets the memory size in MiB (default 256 MiB)\n"
             "       --memory_addr sets the memory start address (default 0x%lx)\n"
             "       --bootrom load in a bootrom img file (default is dromajo bootrom)\n"
             "       --dtb load in a dtb file (default is dromajo dtb)\n"
             "       --compact_bootrom have dtb be directly after bootrom (default 256B after boot base)\n"
             "       --reset_vector set reset vector for all cores (default 0x%lx)\n"
             "       --plic START:SIZE set PLIC start address and size in B (defaults to 0x%lx:0x%lx)\n"
             "       --clint START:SIZE set CLINT start address and size in B (defaults to 0x%lx:0x%lx)\n"
             "       --custom_extension add X extension to misa for all cores\n"
+            "       --checkpoint creates a checkpoint evey N instructions\n"
 #ifdef LIVECACHE
             "       --live_cache_size live cache warmup for checkpoint (default 8M)\n"
 #endif
             "       --clear_ids clear mvendorid, marchid, mimpid for all cores\n",
             msg,
             CONFIG_VERSION,
             prog,
             (long)BOOT_BASE_ADDR,
             (long)RAM_BASE_ADDR,
             (long)PLIC_BASE_ADDR,
@@ -632,20 +633,21 @@ RISCVMachine *virt_machine_main(int argc, char **argv) {
     bool        dump_memories            = false;
     char *      bootrom_name             = 0;
     char *      dtb_name                 = 0;
     bool        compact_bootrom          = false;
     uint64_t    reset_vector_override    = 0;
     uint64_t    plic_base_addr_override  = 0;
     uint64_t    plic_size_override       = 0;
     uint64_t    clint_base_addr_override = 0;
     uint64_t    clint_size_override      = 0;
     bool        custom_extension         = false;
+    uint64_t    checkpoint               = 0;
     const char *simpoint_file            = 0;
     bool        clear_ids                = false;
 #ifdef LIVECACHE
     uint64_t live_cache_size = 8 * 1024 * 1024;
 #endif
     bool elf_based   = false;
     bool allow_ctrlc = false;
 
     dromajo_stdout = stdout;
     dromajo_stderr = stderr;
@@ -667,20 +669,21 @@ RISCVMachine *virt_machine_main(int argc, char **argv) {
             {"dump_memories",                 no_argument, 0,  'D' }, // CFG
             {"memory_size",             required_argument, 0,  'M' }, // CFG
             {"memory_addr",             required_argument, 0,  'A' }, // CFG
             {"bootrom",                 required_argument, 0,  'b' }, // CFG
             {"compact_bootrom",               no_argument, 0,  'o' },
             {"reset_vector",            required_argument, 0,  'r' }, // CFG
             {"dtb",                     required_argument, 0,  'd' }, // CFG
             {"plic",                    required_argument, 0,  'p' }, // CFG
             {"clint",                   required_argument, 0,  'C' }, // CFG
             {"custom_extension",              no_argument, 0,  'u' }, // CFG
+            {"checkpoint",              required_argument, 0,  'e' }, // CFG
             {"clear_ids",                     no_argument, 0,  'L' }, // CFG
             {"ctrlc",                         no_argument, 0,  'X' },
 #ifdef LIVECACHE
             {"live_cache_size",         required_argument, 0,  'w' }, // CFG
 #endif
             {0,                         0,                 0,  0 }
         };
         // clang-format on
 
         int c = getopt_long(argc, argv, "", long_options, &option_index);
@@ -810,20 +813,35 @@ RISCVMachine *virt_machine_main(int argc, char **argv) {
 
                 if (clint_size[0] != '0' || clint_size[1] != 'x')
                     usage(prog, "--clint SIZE must begin with 0x...");
                 clint_size_override = strtoll(clint_size + 2, NULL, 16);
 
                 free(copy);
             } break;
 
             case 'u': custom_extension = true; break;
 
+            case 'e':
+                if(checkpoint)
+                    usage(prog, "already had a checkpoint period");
+                checkpoint = (uint64_t)atoll(optarg);
+                {
+                    char last = optarg[strlen(optarg) - 1];
+                    if (last == 'k' || last == 'K')
+                        checkpoint *= 1000;
+                    else if (last == 'm' || last == 'M')
+                        checkpoint *= 1000000;
+                    else if (last == 'g' || last == 'G')
+                        checkpoint *= 1000000000;
+                }
+                break;
+
             case 'L': clear_ids = true; break;
 
 #ifdef LIVECACHE
             case 'w':
                 if (live_cache_size)
                     usage(prog, "already had a live_cache_size");
                 live_cache_size = (uint64_t)atoll(optarg);
                 {
                     char last = optarg[strlen(optarg) - 1];
                     if (last == 'k' || last == 'K')
@@ -988,20 +1006,23 @@ RISCVMachine *virt_machine_main(int argc, char **argv) {
     // CLINT params
     if (clint_base_addr_override)
         p->clint_base_addr = clint_base_addr_override;
     if (clint_size_override)
         p->clint_size = clint_size_override;
 
     // core modifications
     p->custom_extension = custom_extension;
     p->clear_ids        = clear_ids;
 
+    // checkpoint
+    p->checkpoint = checkpoint;
+
     RISCVMachine *s = virt_machine_init(p);
     if (!s)
         return NULL;
 
 #ifdef LIVECACHE
     // LiveCache (should be ~2x larger than real LLC)
     s->llc = new LiveCache("LiveCache", live_cache_size, p->ram_base_addr, p->ram_size);
 #endif
 
     if (elf_based) {
diff --git a/src/iomem.cpp b/src/iomem.cpp
index 3c789b9..b4a6381 100644
--- a/src/iomem.cpp
+++ b/src/iomem.cpp
@@ -42,20 +42,26 @@
 
 #include <assert.h>
 #include <inttypes.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "cutils.h"
 #include "dromajo.h"
 
+
+void     DefaultInitFunc(void *opaque) { }
+void     DefaultWriteFunc(void *opaque, uint32_t offset, uint32_t val, int size_log2) { }
+uint32_t DefaultReadFunc(void *opaque, uint32_t offset, int size_log2) { return 0; }
+void     DefaultTickFunc(void *opaque, int n_cycles) { }
+
 static PhysMemoryRange *default_register_ram(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags);
 static void             default_free_ram(PhysMemoryMap *s, PhysMemoryRange *pr);
 static const uint32_t * default_get_dirty_bits(PhysMemoryMap *map, PhysMemoryRange *pr);
 static void             default_set_addr(PhysMemoryMap *map, PhysMemoryRange *pr, uint64_t addr, BOOL enabled);
 
 PhysMemoryMap *phys_mem_map_init(void) {
     PhysMemoryMap *s  = (PhysMemoryMap *)mallocz(sizeof(PhysMemoryMap));
     s->register_ram   = default_register_ram;
     s->free_ram       = default_free_ram;
     s->get_dirty_bits = default_get_dirty_bits;
@@ -153,37 +159,39 @@ static const uint32_t *default_get_dirty_bits(PhysMemoryMap *map, PhysMemoryRang
     }
 
     pr->dirty_bits_index ^= 1;
     pr->dirty_bits = pr->dirty_bits_tab[pr->dirty_bits_index];
     memset(pr->dirty_bits, 0, pr->dirty_bits_size);
     return dirty_bits;
 }
 
 static void default_free_ram(PhysMemoryMap *s, PhysMemoryRange *pr) { free(pr->phys_mem); }
 
-PhysMemoryRange *cpu_register_device(PhysMemoryMap *s, uint64_t addr, uint64_t size, void *opaque, DeviceReadFunc *read_func,
-                                     DeviceWriteFunc *write_func, int devio_flags) {
+PhysMemoryRange *cpu_register_device(PhysMemoryMap *s, uint64_t addr, uint64_t size, void *opaque, DeviceInitFunc *init_func, DeviceReadFunc *read_func,
+                                     DeviceWriteFunc *write_func, DeviceTickFunc *tick_func, int devio_flags) {
     PhysMemoryRange *pr;
     assert(s->n_phys_mem_range < PHYS_MEM_RANGE_MAX);
     assert(size <= 0xffffffff);
     pr           = &s->phys_mem_range[s->n_phys_mem_range++];
     pr->map      = s;
     pr->addr     = addr;
     pr->org_size = size;
     if (devio_flags & DEVIO_DISABLED)
         pr->size = 0;
     else
         pr->size = pr->org_size;
     pr->is_ram      = FALSE;
     pr->opaque      = opaque;
+    pr->init_func   = init_func;
     pr->read_func   = read_func;
     pr->write_func  = write_func;
+    pr->tick_func   = tick_func;
     pr->devio_flags = devio_flags;
     return pr;
 }
 
 static void default_set_addr(PhysMemoryMap *map, PhysMemoryRange *pr, uint64_t addr, BOOL enabled) {
     if (enabled) {
         if (pr->size == 0 || pr->addr != addr) {
             /* enable or move mapping */
             if (pr->is_ram) {
                 map->flush_tlb_write_range(map->opaque, pr->phys_mem, pr->org_size);
diff --git a/src/pci.cpp b/src/pci.cpp
index 345fd00..ca1625e 100644
--- a/src/pci.cpp
+++ b/src/pci.cpp
@@ -473,22 +473,22 @@ I440FXState *i440fx_init(PCIBus **pbus, int *ppiix3_devfn, PhysMemoryMap *mem_ma
 
     b->bus_num  = 0;
     b->mem_map  = mem_map;
     b->port_map = port_map;
 
     s->pic_irqs = pic_irqs;
     for (int i = 0; i < 4; i++) {
         irq_init(&b->irq[i], i440fx_set_irq, s, i);
     }
 
-    cpu_register_device(port_map, 0xcf8, 1, s, i440fx_read_addr, i440fx_write_addr, DEVIO_SIZE32);
-    cpu_register_device(port_map, 0xcfc, 4, s, i440fx_read_data, i440fx_write_data, DEVIO_SIZE8 | DEVIO_SIZE16 | DEVIO_SIZE32);
+    cpu_register_device(port_map, 0xcf8, 1, s, DefaultInitFunc, i440fx_read_addr, i440fx_write_addr, DefaultTickFunc, DEVIO_SIZE32);
+    cpu_register_device(port_map, 0xcfc, 4, s, DefaultInitFunc, i440fx_read_data, i440fx_write_data, DefaultTickFunc, DEVIO_SIZE8 | DEVIO_SIZE16 | DEVIO_SIZE32);
     PCIDevice *d = pci_register_device(b, "i440FX", 0, 0x8086, 0x1237, 0x02, 0x0600);
     put_le16(&d->config[PCI_SUBSYSTEM_VENDOR_ID], 0x1af4); /* Red Hat, Inc. */
     put_le16(&d->config[PCI_SUBSYSTEM_ID], 0x1100);        /* QEMU virtual machine */
 
     s->pci_dev = d;
     s->pci_bus = b;
 
     s->piix3_dev = pci_register_device(b, "PIIX3", 8, 0x8086, 0x7000, 0x00, 0x0601);
     pci_device_set_config8(s->piix3_dev, 0x0e, 0x80); /* header type */
 
diff --git a/src/riscv_cpu.cpp b/src/riscv_cpu.cpp
index 5a29bdb..d20be19 100644
--- a/src/riscv_cpu.cpp
+++ b/src/riscv_cpu.cpp
@@ -171,32 +171,36 @@ static inline uint64_t track_dread(RISCVCPUState *s, uint64_t vaddr, uint64_t pa
 static inline uint64_t track_iread(RISCVCPUState *s, uint64_t vaddr, uint64_t paddr, uint64_t data, int size) {
 #ifdef LIVECACHE
     s->machine->llc->read(paddr);
 #endif
     // printf("track.ic[%llx:%llx]=%llx\n", paddr, paddr+size-1, data);
     assert(size == 16 || size == 32);
 
     return data;
 }
 
+#include <iostream>
 /* "PMP checks are applied to all accesses when the hart is running in
  * S or U modes, and for loads and stores when the MPRV bit is set in
  * the mstatus register and the MPP field in the mstatus register
  * contains S or U. Optionally, PMP checks may additionally apply to
  * M-mode accesses, in which case the PMP registers themselves are
  * locked, so that even M-mode software cannot change them without a
  * system reset.  In effect, PMP can grant permissions to S and U
  * modes, which by default have none, and can revoke permissions from
  * M-mode, which by default has full permissions." */
 bool riscv_cpu_pmp_access_ok(RISCVCPUState *s, uint64_t paddr, size_t size, pmpcfg_t perm) {
     int priv;
 
+    // BlackParrot has no PMP
+    return true;
+
     /* rv64mi-p-access expects illegal physical addresses to fail. */
     if ((uint64_t)paddr >> s->physical_addr_len != 0)
         return false;
 
     if ((s->mstatus & MSTATUS_MPRV) && !(perm & PMPCFG_X)) {
         /* use previous privilege */
         priv = (s->mstatus >> MSTATUS_MPP_SHIFT) & 3;
     } else {
         priv = s->priv;
     }
@@ -1173,36 +1177,35 @@ bool vectorize_arithmetic(RISCVCPUState *s, uint8_t vs2, uint8_t vd, target_ulon
     (MSTATUS_SIE | MSTATUS_SPIE | MSTATUS_SPP | MSTATUS_VS | MSTATUS_FS | MSTATUS_SUM | MSTATUS_MXR | MSTATUS_UXL_MASK)
 
 #define MSTATUS_MASK                                                                                                              \
     (MSTATUS_SIE | MSTATUS_MIE | MSTATUS_SPIE | MSTATUS_MPIE | MSTATUS_SPP | MSTATUS_MPP | MSTATUS_VS | MSTATUS_FS | MSTATUS_MPRV \
      | MSTATUS_SUM | MSTATUS_MXR | MSTATUS_TVM | MSTATUS_TW | MSTATUS_TSR | MSTATUS_UXL_MASK | MSTATUS_SXL_MASK)
 
 /* return the complete mstatus with the SD bit */
 static target_ulong get_mstatus(RISCVCPUState *s, target_ulong mask) {
     target_ulong val;
     BOOL         sd;
-    val = s->mstatus | (s->fs << MSTATUS_FS_SHIFT) | (s->vs << MSTATUS_VS_SHIFT);
+    val = s->mstatus | (s->fs << MSTATUS_FS_SHIFT);
     val &= mask;
     sd = ((val & MSTATUS_VS) == MSTATUS_VS) | ((val & MSTATUS_FS) == MSTATUS_FS) | ((val & MSTATUS_XS) == MSTATUS_XS);
     if (sd)
         val |= (target_ulong)1 << 63;
     return val;
 }
 
 static void set_mstatus(RISCVCPUState *s, target_ulong val) {
     /* flush the TLBs if change of MMU config */
     target_ulong mod = s->mstatus ^ val;
     if ((mod & (MSTATUS_MPRV | MSTATUS_SUM | MSTATUS_MXR)) != 0 || ((s->mstatus & MSTATUS_MPRV) && (mod & MSTATUS_MPP) != 0)) {
         tlb_flush_all(s);
     }
     s->fs = (val >> MSTATUS_FS_SHIFT) & 3;
-    s->vs = (val >> MSTATUS_VS_SHIFT) & 3;
 
     target_ulong mask = MSTATUS_MASK & ~(MSTATUS_FS | MSTATUS_VS | MSTATUS_UXL_MASK | MSTATUS_SXL_MASK);
     s->mstatus        = s->mstatus & ~mask | val & mask;
 }
 
 static BOOL counter_access_ok(RISCVCPUState *s, uint32_t csr) {
     uint32_t counteren = 0;
 
     switch (s->priv) {
         case PRV_U: counteren = s->scounteren; break;
@@ -2009,33 +2012,45 @@ static void raise_exception(RISCVCPUState *s, uint64_t cause) { raise_exception2
 
 static void handle_sret(RISCVCPUState *s) {
     /* Copy down SPIE to SIE and set SPIE */
     s->mstatus &= ~MSTATUS_SIE;
     s->mstatus |= (s->mstatus >> 4) & MSTATUS_SIE;
     s->mstatus |= MSTATUS_SPIE;
 
     int spp = (s->mstatus & MSTATUS_SPP) >> MSTATUS_SPP_SHIFT;
     s->mstatus &= ~MSTATUS_SPP;
 
+    // Clear MPRV on non m-mode sret
+    switch (spp) {
+      case PRV_M: break;
+      default: s->mstatus &= ~MSTATUS_MPRV;
+    }
+
     set_priv(s, spp);
     s->pc = s->sepc;
 }
 
 static void handle_mret(RISCVCPUState *s) {
     /* Copy down MPIE to MIE and set MPIE */
     s->mstatus &= ~MSTATUS_MIE;
     s->mstatus |= (s->mstatus >> 4) & MSTATUS_MIE;
     s->mstatus |= MSTATUS_MPIE;
 
     int mpp = (s->mstatus & MSTATUS_MPP) >> MSTATUS_MPP_SHIFT;
     s->mstatus &= ~MSTATUS_MPP;
 
+    // Clear MPRV on non m-mode mret
+    switch (mpp) {
+      case PRV_M: break;
+      default: s->mstatus &= ~MSTATUS_MPRV;
+    }
+
     set_priv(s, mpp);
     s->pc = s->mepc;
 }
 
 static void handle_dret(RISCVCPUState *s) {
     s->stop_the_counter = FALSE;  // Enable counters again
     s->debug_mode       = FALSE;
     set_priv(s, s->dcsr & 3);
     s->pc = s->dpc;
 }
@@ -2166,37 +2181,37 @@ static sfloat64 f_unbox64(sfloat64 r) { return r; }
 #include "dromajo_template.h"
 
 int riscv_cpu_interp(RISCVCPUState *s, int n_cycles) { return riscv_cpu_interp64(s, n_cycles); }
 
 /* Note: the value is not accurate when called in riscv_cpu_interp() */
 uint64_t riscv_cpu_get_cycles(RISCVCPUState *s) { return s->mcycle; }
 
 void riscv_cpu_set_mip(RISCVCPUState *s, uint32_t mask) {
     s->mip |= mask;
     /* exit from power down if an interrupt is pending */
-    if (s->power_down_flag && (s->mip & s->mie) != 0 && (s->machine->common.pending_interrupt != -1 || !s->machine->common.cosim))
+    if (s->power_down_flag && (s->mip & s->mie) != 0 && (s->pending_interrupt != -1 || !s->machine->common.cosim))
         s->power_down_flag = FALSE;
 }
 
 void riscv_cpu_reset_mip(RISCVCPUState *s, uint32_t mask) { s->mip &= ~mask; }
 
 uint32_t riscv_cpu_get_mip(RISCVCPUState *s) { return s->mip; }
 
 BOOL riscv_cpu_get_power_down(RISCVCPUState *s) { return s->power_down_flag; }
 
 RISCVCPUState *riscv_cpu_init(RISCVMachine *machine, int hartid) {
     RISCVCPUState *s      = (RISCVCPUState *)mallocz(sizeof *s);
     s->machine            = machine;
     s->mem_map            = machine->mem_map;
     s->pc                 = machine->reset_vector;
     s->priv               = PRV_M;
-    s->mstatus            = ((uint64_t)2 << MSTATUS_UXL_SHIFT) | ((uint64_t)2 << MSTATUS_SXL_SHIFT) | (3 << MSTATUS_MPP_SHIFT);
+    s->mstatus            = ((uint64_t)2 << MSTATUS_UXL_SHIFT) | ((uint64_t)2 << MSTATUS_SXL_SHIFT) | (0 << MSTATUS_MPP_SHIFT);
     s->plic_enable_irq[0] = 0;
     s->plic_enable_irq[1] = 0;
     s->misa |= MCPUID_SUPER | MCPUID_USER | MCPUID_I | MCPUID_M | MCPUID_A;
     s->most_recently_written_reg = -1;
 #if FLEN >= 32
     s->most_recently_written_fp_reg = -1;
     s->misa |= MCPUID_F;
 #endif
 #if FLEN >= 64
     s->misa |= MCPUID_D;
@@ -2324,40 +2339,40 @@ int riscv_get_most_recently_written_fp_reg(RISCVCPUState *s) { return s->most_re
 int riscv_benchmark_exit_code(RISCVCPUState *s) { return s->benchmark_exit_code; }
 
 void riscv_get_ctf_info(RISCVCPUState *s, RISCVCTFInfo *info) { *info = s->info; }
 
 void riscv_get_ctf_target(RISCVCPUState *s, uint64_t *target) { *target = s->next_addr; }
 
 BOOL riscv_terminated(RISCVCPUState *s) { return s->terminate_simulation; }
 
 void riscv_set_debug_mode(RISCVCPUState *s, bool on) { s->debug_mode = on; }
 
-static void serialize_memory(const void *base, size_t size, const char *file) {
+void serialize_memory(const void *base, size_t size, const char *file) {
     int f_fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, 0777);
 
     if (f_fd < 0)
         err(-3, "trying to write %s", file);
 
     char *potr = (char *)base;
 
     while (size) {
         ssize_t written = write(f_fd, potr, size);
         if (written <= 0)
             err(-3, "while writing %s", file);
         size -= written;
         potr += written;
     }
 
     close(f_fd);
 }
 
-static void deserialize_memory(void *base, size_t size, const char *file) {
+void deserialize_memory(void *base, size_t size, const char *file) {
     int f_fd = open(file, O_RDONLY);
 
     if (f_fd < 0)
         err(-3, "trying to read %s", file);
 
     char *potr = (char *)base;
     while (size) {
       ssize_t sz = read(f_fd, potr, size);
       if (sz < 0)
         err(-3, "%s %zd size does not match memory size %zd", file, sz, size);
@@ -2490,66 +2505,71 @@ static void create_reg_recovery(uint32_t *rom, uint32_t *code_pos, uint32_t *dat
     uint32_t data_off = sizeof(uint32_t) * (*data_pos - *code_pos);
 
     rom[(*code_pos)++] = create_auipc(rn, data_off);
     rom[(*code_pos)++] = create_addi(rn, data_off);
     rom[(*code_pos)++] = create_ld(rn, rn);
 
     rom[(*data_pos)++] = val & 0xFFFFFFFF;
     rom[(*data_pos)++] = val >> 32;
 }
 
-static void create_io64_recovery(uint32_t *rom, uint32_t *code_pos, uint32_t *data_pos, uint64_t addr, uint64_t val) {
+static void __attribute__((unused)) create_io64_recovery(uint32_t *rom, uint32_t *code_pos, uint32_t *data_pos, uint64_t addr, uint64_t val) {
     uint32_t data_off = sizeof(uint32_t) * (*data_pos - *code_pos);
 
     rom[(*code_pos)++] = create_auipc(1, data_off);
     rom[(*code_pos)++] = create_addi(1, data_off);
     rom[(*code_pos)++] = create_ld(1, 1);
 
     rom[(*data_pos)++] = addr & 0xFFFFFFFF;
     rom[(*data_pos)++] = addr >> 32;
 
     uint32_t data_off2 = sizeof(uint32_t) * (*data_pos - *code_pos);
     rom[(*code_pos)++] = create_auipc(2, data_off2);
     rom[(*code_pos)++] = create_addi(2, data_off2);
     rom[(*code_pos)++] = create_ld(2, 2);
 
     rom[(*code_pos)++] = create_sd(1, 2);
 
     rom[(*data_pos)++] = val & 0xFFFFFFFF;
     rom[(*data_pos)++] = val >> 32;
 }
 
-static void create_hang_nonzero_hart(uint32_t *rom, uint32_t *code_pos, uint32_t *data_pos) {
+void create_hang_nonzero_hart(uint32_t *rom, uint32_t *code_pos, uint32_t *data_pos) {
     /* Note, this matches the boot loader prologue from copy_kernel() */
 
     rom[(*code_pos)++] = 0xf1402573;  // start:  csrr   a0, mhartid
     rom[(*code_pos)++] = 0x00050663;  //         beqz   a0, 1f
     rom[(*code_pos)++] = 0x10500073;  // 0:      wfi
     rom[(*code_pos)++] = 0xffdff06f;  //         j      0b
                                       // 1:
 }
 
-static void create_boot_rom(RISCVCPUState *s, const char *file, const uint64_t clint_base_addr) {
-    uint32_t rom[ROM_SIZE / 4];
+void create_boot_rom(RISCVMachine *m, const char *file, const uint64_t clint_base_addr) {
+    int ROMSize = ROM_SIZE * m->ncpus;
+    uint32_t rom[ROMSize / 4];
     memset(rom, 0, sizeof rom);
 
     // ROM organization
     // 0000..003F wasted
     // 0040..0AFF boot code (2,752 B)
     // 0B00..0FFF boot data (  512 B)
+    for(int k = 0; k < m->ncpus; k++) {
+
+    RISCVCPUState* s = m->cpu_state[k];
 
     uint32_t code_pos       = (BOOT_BASE_ADDR - ROM_BASE_ADDR) / sizeof *rom;
-    uint32_t data_pos       = 0xB00 / sizeof *rom;
-    uint32_t data_pos_start = data_pos;
+    uint32_t core_off       = (k << 10) / sizeof *rom;
+    uint32_t data_pos       = core_off + (0xB00 / sizeof *rom);
+    //uint32_t data_pos_start = data_pos;
 
-    if (s->machine->ncpus == 1)  // FIXME: May be interesting to freeze hartid >= ncpus
-        create_hang_nonzero_hart(rom, &code_pos, &data_pos);
+    //if (s->machine->ncpus == 1)  // FIXME: May be interesting to freeze hartid >= ncpus
+    //    create_hang_nonzero_hart(rom, &code_pos, &data_pos);
 
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x7b1, s->pc);  // Write to DPC (CSR, 0x7b1)
 
     // Write current priviliege level to prv in dcsr (0 user, 1 supervisor, 2 user)
     // dcsr is at 0x7b0 prv is bits 0 & 1
     // dcsr.stopcount = 1
     // dcsr.stoptime  = 1
     // dcsr = 0x600 | (PrivLevel & 0x3)
     if (s->priv == 2) {
         fprintf(dromajo_stderr, "UNSUPORTED Priv mode (no hyper)\n");
@@ -2622,77 +2642,78 @@ static void create_boot_rom(RISCVCPUState *s, const char *file, const uint64_t c
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x302, s->medeleg);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x303, s->mideleg);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x304, s->mie);  // mie & sie
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x305, s->mtvec);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x105, s->stvec);
     create_csr12_recovery(rom, &code_pos, 0x320, s->mcountinhibit);
     create_csr12_recovery(rom, &code_pos, 0x306, s->mcounteren);
     create_csr12_recovery(rom, &code_pos, 0x106, s->scounteren);
 
     // NB: restore addr before cfgs for fewer surprises!
-    for (int i = 0; i < 16; ++i) create_csr64_recovery(rom, &code_pos, &data_pos, CSR_PMPADDR(i), s->csr_pmpaddr[i]);
-    for (int i = 0; i < 4; i += 2) create_csr64_recovery(rom, &code_pos, &data_pos, CSR_PMPCFG(i), s->csr_pmpcfg[i]);
+    //for (int i = 0; i < 16; ++i) create_csr64_recovery(rom, &code_pos, &data_pos, CSR_PMPADDR(i), s->csr_pmpaddr[i]);
+    //for (int i = 0; i < 4; i += 2) create_csr64_recovery(rom, &code_pos, &data_pos, CSR_PMPCFG(i), s->csr_pmpcfg[i]);
 
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x340, s->mscratch);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x341, s->mepc);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x342, s->mcause);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x343, s->mtval);
 
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x140, s->sscratch);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x141, s->sepc);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x142, s->scause);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x143, s->stval);
 
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x344, s->mip);  // mip & sip
 
     for (int i = 3; i < 32; i++) {  // Not 1 and 2 which are used by create_...
         create_reg_recovery(rom, &code_pos, &data_pos, i, s->reg[i]);
     }
 
     // Recover CLINT (Close to the end of the recovery to avoid extra cycles)
     // TODO: One per hart (multicore/SMP)
 
-    fprintf(dromajo_stderr,
-            "clint hartid=%d timecmp=%" PRId64 " cycles (%" PRId64 ")\n",
-            (int)s->mhartid,
-            s->timecmp,
-            s->mcycle / RTC_FREQ_DIV);
+    //fprintf(dromajo_stderr,
+    //        "clint hartid=%d timecmp=%" PRId64 " cycles (%" PRId64 ")\n",
+    //        (int)s->mhartid,
+    //        s->timecmp,
+    //        s->mcycle / RTC_FREQ_DIV);
 
     // Assuming 16 ratio between CPU and CLINT and that CPU is reset to zero
-    create_io64_recovery(rom, &code_pos, &data_pos, clint_base_addr + 0x4000, s->timecmp);
+    //create_io64_recovery(rom, &code_pos, &data_pos, clint_base_addr + 0x4000, s->timecmp);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0xb02, s->minstret);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0xb00, s->mcycle);
 
-    create_io64_recovery(rom, &code_pos, &data_pos, clint_base_addr + 0xbff8, s->mcycle / RTC_FREQ_DIV);
+    //create_io64_recovery(rom, &code_pos, &data_pos, clint_base_addr + 0xbff8, s->mcycle / RTC_FREQ_DIV);
 
     for (int i = 1; i < 3; i++) {  // recover 1 and 2 now
         create_reg_recovery(rom, &code_pos, &data_pos, i, s->reg[i]);
     }
 
     rom[code_pos++] = create_csrrw(1, 0x7b2);
     create_csr64_recovery(rom, &code_pos, &data_pos, 0x180, s->satp);
     // last Thing because it changes addresses. Use dscratch register to remember reg 1
     rom[code_pos++] = create_csrrs(1, 0x7b2);
 
     // dret 0x7b200073
     rom[code_pos++] = 0x7b200073;
 
-    if (sizeof rom / sizeof *rom <= data_pos || data_pos_start <= code_pos) {
-        fprintf(dromajo_stderr,
-                "ERROR: ROM is too small. ROM_SIZE should increase.  "
-                "Current code_pos=%d data_pos=%d\n",
-                code_pos,
-                data_pos);
-        exit(-6);
+    //if (sizeof rom / sizeof *rom <= data_pos || data_pos_start <= code_pos) {
+    //    fprintf(dromajo_stderr,
+    //            "ERROR: ROM is too small. ROM_SIZE should increase.  "
+    //            "Current code_pos=%d data_pos=%d\n",
+    //            code_pos,
+    //            data_pos);
+    //    exit(-6);
+    //}
     }
 
-    serialize_memory(rom, ROM_SIZE, file);
+    serialize_memory(rom, ROMSize, file);
 }
 
 void riscv_cpu_serialize(RISCVCPUState *s, const char *dump_name, const uint64_t clint_base_addr) {
     FILE * conf_fd   = 0;
     size_t n         = strlen(dump_name) + 64;
     char * conf_name = (char *)alloca(n);
     snprintf(conf_name, n, "%s.re_regs", dump_name);
 
     conf_fd = fopen(conf_name, "w");
     if (conf_fd == 0)
@@ -2773,21 +2794,21 @@ void riscv_cpu_serialize(RISCVCPUState *s, const char *dump_name, const uint64_t
         fprintf(dromajo_stderr, "ERROR: could not find boot and main ram???\n");
         exit(-3);
     }
 
     n            = strlen(dump_name) + 64;
     char *f_name = (char *)alloca(n);
     snprintf(f_name, n, "%s.bootram", dump_name);
 
     if (s->priv != 3 || ROM_BASE_ADDR + ROM_SIZE < s->pc) {
         fprintf(dromajo_stderr, "NOTE: creating a new boot rom\n");
-        create_boot_rom(s, f_name, clint_base_addr);
+        create_boot_rom(s->machine, f_name, clint_base_addr);
     } else if (BOOT_BASE_ADDR < s->pc) {
         fprintf(dromajo_stderr, "ERROR: could not checkpoint when running inside the ROM\n");
         exit(-4);
     } else if (s->pc == BOOT_BASE_ADDR && boot_ram) {
         fprintf(dromajo_stderr, "NOTE: using the default dromajo ROM\n");
         serialize_memory(boot_ram->phys_mem, boot_ram->size, f_name);
     } else {
         fprintf(dromajo_stderr, "ERROR: unexpected PC address 0x%llx\n", (long long)s->pc);
         exit(-4);
     }
diff --git a/src/riscv_machine.cpp b/src/riscv_machine.cpp
index cb15491..c67944e 100644
--- a/src/riscv_machine.cpp
+++ b/src/riscv_machine.cpp
@@ -44,20 +44,24 @@
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <queue>
+#include <string>
+#include <fstream>
+#include <sstream>
 
 #include "cutils.h"
 #include "dromajo.h"
 #include "dw_apb_uart.h"
 #include "elf64.h"
 #include "iomem.h"
 
 /* RISCV machine */
 
 //#define DUMP_UART
@@ -404,20 +408,120 @@ static void plic_set_irq(void *opaque, int irq_num, int state) {
     if (state)
         m->plic_pending_irq |= mask;
     else
         m->plic_pending_irq &= ~mask;
 
     for (int hartid = 0; hartid < m->ncpus; ++hartid) {
         plic_update_mip(m, hartid);
     }
 }
 
+std::ofstream sigfile;
+static void host_init(void *opaque) {
+  RISCVMachine *m = (RISCVMachine *)opaque;
+  if (m->common.cosim)
+    return;
+  
+  sigfile.open("signature.txt");
+}
+
+static uint32_t host_read(void *opaque, uint32_t offset, int size_log2) {
+  RISCVMachine *m = (RISCVMachine *)opaque;
+  CharacterDevice *cs = m->common.console;
+  unsigned char r;
+  if (m->common.cosim)
+    return -1;
+
+  switch (offset & HOST_MASK) {
+    case HOST_GETCHAR:
+      if (cs->read_data(cs->opaque, &r, 1)) {
+        return (uint32_t) r;
+      }
+      return -1;
+    default:
+      vm_error("illegal host_read: offset=%x\n", offset);
+      exit(1);
+    }
+}
+
+static void host_write(void *opaque, uint32_t offset, uint32_t val, int size_log2) {
+  RISCVMachine *m = (RISCVMachine *)opaque;
+  CharacterDevice *cs = m->common.console;
+  if (m->common.cosim)
+    return;
+
+  std::ostringstream oss;
+  std::string str;
+  const char* pass_fail = (val == 0)? "PASS" : "FAIL";
+  oss << "[CORE FSH] " << pass_fail << "\n";
+  for (int i = 0; i < m->ncpus; i++) {
+      oss << "\tinstret: " << m->cpu_state[i]->minstret << std::endl;
+  }
+
+  switch (offset & HOST_MASK) {
+    case HOST_PUTCHAR:
+    case HOST_GPUTCHAR:
+      str = std::string(1, val);
+      cs->write_data(cs->opaque, reinterpret_cast<const uint8_t*>(str.data()), str.size());
+      break;
+    case HOST_FINISH:
+      str = oss.str();
+      cs->write_data(cs->opaque, reinterpret_cast<const uint8_t*>(str.data()), str.size());
+      m->keep_going = false;
+      break;
+    case HOST_SIG:
+      str = std::to_string(val);
+      sigfile << str << std::endl;
+      break;
+    case HOST_PUTINT:
+      str = std::to_string(val);
+      cs->write_data(cs->opaque, reinterpret_cast<const uint8_t*>(str.data()), str.size());
+      break;
+    default:
+      vm_error("illegal host_write: offset=%x val=%x\n", offset, val);
+      exit(1);
+  }
+}
+
+static uint32_t param_rom_read(void *opaque, uint32_t offset, int size_log2) {
+  // Hard-coded for supported BP configurations
+  // Only implement CC_X_DIM and CC_Y_DIM since those are only used by test programs
+  RISCVMachine *m = (RISCVMachine *)opaque;
+  if (offset == PARAM_CC_X_DIM) {
+    if (m->ncpus == 1) return 1;
+    if (m->ncpus == 2) return 2;
+    if (m->ncpus == 3) return 3;
+    if (m->ncpus == 4) return 2;
+    if (m->ncpus == 6) return 3;
+    if (m->ncpus == 8) return 4;
+    if (m->ncpus == 12) return 4;
+    if (m->ncpus == 16) return 4;
+  }
+  else if (offset == PARAM_CC_Y_DIM) {
+    if (m->ncpus == 1) return 1;
+    if (m->ncpus == 2) return 1;
+    if (m->ncpus == 3) return 1;
+    if (m->ncpus == 4) return 2;
+    if (m->ncpus == 6) return 2;
+    if (m->ncpus == 8) return 2;
+    if (m->ncpus == 12) return 3;
+    if (m->ncpus == 16) return 4;
+  }
+  else if (offset > PARAM_ROM_SIZE) {
+    vm_error("param_rom_read to address beyond ROM: PARAM_ROM_BASE_ADDR+0x%x\n", offset);
+  }
+  else {
+    vm_error("param_rom_read to unimplemented address PARAM_ROM_BASE_ADDR+0x%x\n", offset);
+  }
+  return -1;
+}
+
 static uint8_t *get_ram_ptr(RISCVMachine *s, uint64_t paddr) {
     PhysMemoryRange *pr = get_phys_mem_range(s->mem_map, paddr);
     if (!pr || !pr->is_ram)
         return NULL;
     return pr->phys_mem + (uintptr_t)(paddr - pr->addr);
 }
 
 /* FDT machine description */
 
 #define FDT_MAGIC   0xd00dfeed
@@ -1152,20 +1256,21 @@ RISCVMachine *virt_machine_init(const VirtMachineParams *p) {
     RISCVMachine *s = (RISCVMachine *)mallocz(sizeof *s);
 
     s->ram_size      = p->ram_size;
     s->ram_base_addr = p->ram_base_addr;
 
     s->mem_map = phys_mem_map_init();
     /* needed to handle the RAM dirty bits */
     s->mem_map->opaque                = s;
     s->mem_map->flush_tlb_write_range = riscv_flush_tlb_write_range;
     s->common.maxinsns                = p->maxinsns;
+    s->common.checkpoint              = p->checkpoint;
     s->common.snapshot_load_name      = p->snapshot_load_name;
 
     /* loggers are changed using install_new_loggers() in dromajo_cosim */
     s->common.debug_log = &dromajo_default_debug_log;
     s->common.error_log = &dromajo_default_error_log;
 
     s->ncpus = p->ncpus;
 
     /* setup reset vector for core
      * note: must be above riscv_cpu_init
@@ -1178,72 +1283,106 @@ RISCVMachine *virt_machine_init(const VirtMachineParams *p) {
     /* add custom extension bit to misa */
     s->custom_extension = p->custom_extension;
 
     s->plic_base_addr  = p->plic_base_addr;
     s->plic_size       = p->plic_size;
     s->clint_base_addr = p->clint_base_addr;
     s->clint_size      = p->clint_size;
     /* clear mimpid, marchid, mvendorid */
     s->clear_ids = p->clear_ids;
 
+    /* initialize machine */
+    s->keep_going = true;
+
+    /* running total of committed instructions */
+    s->totalinsns = 0;
+
     if (MAX_CPUS < s->ncpus) {
         vm_error("ERROR: ncpus:%d exceeds maximum MAX_CPU\n", s->ncpus);
         return NULL;
     }
 
     for (int i = 0; i < s->ncpus; ++i) {
         s->cpu_state[i] = riscv_cpu_init(s, i);
     }
 
     /* RAM */
     cpu_register_ram(s->mem_map, s->ram_base_addr, s->ram_size, 0);
-    cpu_register_ram(s->mem_map, ROM_BASE_ADDR, ROM_SIZE, 0);
+    cpu_register_ram(s->mem_map, ROM_BASE_ADDR, ROM_SIZE * s->ncpus, 0);
 
     for (int i = 0; i < s->ncpus; ++i) {
         s->cpu_state[i]->physical_addr_len = p->physical_addr_len;
     }
 
     SiFiveUARTState *uart = (SiFiveUARTState *)calloc(sizeof *uart, 1);
     uart->irq             = UART0_IRQ;
     uart->cs              = p->console;
-    cpu_register_device(s->mem_map, UART0_BASE_ADDR, UART0_SIZE, uart, uart_read, uart_write, DEVIO_SIZE32);
+    cpu_register_device(s->mem_map, UART0_BASE_ADDR, UART0_SIZE, uart, DefaultInitFunc, uart_read, uart_write, DefaultTickFunc, DEVIO_SIZE32);
 
     dw_apb_uart0 = (DW_apb_uart_state *)calloc(sizeof *dw_apb_uart0, 1);
     dw_apb_uart0->irq = &s->plic_irq[DW_APB_UART0_IRQ];
     dw_apb_uart0->cs  = p->console;
     cpu_register_device(s->mem_map,
                         DW_APB_UART0_BASE_ADDR,
                         DW_APB_UART0_SIZE,
                         dw_apb_uart0,
+                        DefaultInitFunc,
                         dw_apb_uart_read,
                         dw_apb_uart_write,
+                        DefaultTickFunc,
                         DEVIO_SIZE32 | DEVIO_SIZE16 | DEVIO_SIZE8);
 
     dw_apb_uart1 = (DW_apb_uart_state *)calloc(sizeof *dw_apb_uart1, 1);
     dw_apb_uart1->irq = &s->plic_irq[DW_APB_UART1_IRQ];
     dw_apb_uart1->cs  = p->console;
     cpu_register_device(s->mem_map,
                         DW_APB_UART1_BASE_ADDR,
                         DW_APB_UART1_SIZE,
                         dw_apb_uart1,
+                        DefaultInitFunc,
                         dw_apb_uart_read,
                         dw_apb_uart_write,
+                        DefaultTickFunc,
                         DEVIO_SIZE32 | DEVIO_SIZE16 | DEVIO_SIZE8);
 
     cpu_register_device(s->mem_map,
                         p->clint_base_addr,
                         p->clint_size,
                         s,
+                        DefaultInitFunc,
                         clint_read,
                         clint_write,
+                        DefaultTickFunc,
+                        DEVIO_SIZE32 | DEVIO_SIZE16 | DEVIO_SIZE8);
+    cpu_register_device(s->mem_map, p->plic_base_addr, p->plic_size, s, DefaultInitFunc, plic_read, plic_write, DefaultTickFunc, DEVIO_SIZE32);
+
+    // BlackParrot Host
+    cpu_register_device(s->mem_map,
+                        HOST_BASE_ADDR,
+                        HOST_SIZE,
+                        s,
+                        host_init,
+                        host_read,
+                        host_write,
+                        DefaultTickFunc,
+                        DEVIO_SIZE32 | DEVIO_SIZE16 | DEVIO_SIZE8);
+
+    // BlackParrot Parameter ROM
+    cpu_register_device(s->mem_map,
+                        PARAM_ROM_BASE_ADDR,
+                        PARAM_ROM_SIZE,
+                        s,
+                        DefaultInitFunc,
+                        param_rom_read,
+                        DefaultWriteFunc,
+                        DefaultTickFunc,
                         DEVIO_SIZE32 | DEVIO_SIZE16 | DEVIO_SIZE8);
-    cpu_register_device(s->mem_map, p->plic_base_addr, p->plic_size, s, plic_read, plic_write, DEVIO_SIZE32);
 
     for (int j = 1; j < 32; j++) {
         irq_init(&s->plic_irq[j], plic_set_irq, s, j);
     }
 
     s->htif_tohost_addr = p->htif_base_addr;
 
     s->common.console = p->console;
 
     memset(vbus, 0, sizeof(*vbus));
@@ -1318,29 +1457,40 @@ RISCVMachine *virt_machine_init(const VirtMachineParams *p) {
                            p->files[VM_FILE_KERNEL].len,
                            p->files[VM_FILE_INITRD].buf,
                            p->files[VM_FILE_INITRD].len,
                            p->bootrom_name,
                            p->dtb_name,
                            p->cmdline))
         return NULL;
 
     /* interrupts and exception setup for cosim */
     s->common.cosim             = false;
-    s->common.pending_exception = -1;
-    s->common.pending_interrupt = -1;
+    for (int i = 0; i < s->ncpus; i++) {
+        s->cpu_state[i]->pending_interrupt = -1;
+        s->cpu_state[i]->pending_exception = -1;
+    }
 
     /* plic/clint setup */
     s->plic_base_addr  = p->plic_base_addr;
     s->plic_size       = p->plic_size;
     s->clint_base_addr = p->clint_base_addr;
     s->clint_size      = p->clint_size;
 
+    /* Initialize devices */
+    for (int i = s->mem_map->n_phys_mem_range - 1; i >= 0; --i) {
+        PhysMemoryRange *pr = &s->mem_map->phys_mem_range[i];
+   
+		if (!pr->is_ram) {
+			pr->init_func(pr->opaque);
+		} 
+    }
+
     return s;
 }
 
 RISCVMachine *virt_machine_load(const VirtMachineParams *p, RISCVMachine *s) {
     if (!p->files[VM_FILE_BIOS].buf) {
         vm_error("No bios given\n");
         return NULL;
     } else if (copy_kernel(s,
                            p->files[VM_FILE_BIOS].buf,
                            p->files[VM_FILE_BIOS].len,
@@ -1390,22 +1540,26 @@ RISCVMachine *virt_machine_load(const VirtMachineParams *p, RISCVMachine *s) {
             }
         }
     }
 
     global_virt_machine = s;
 
     return s;
 }
 
 void virt_machine_end(RISCVMachine *s) {
-    if (s->common.snapshot_save_name)
-        virt_machine_serialize(s, s->common.snapshot_save_name);
+    if (s->common.snapshot_save_name) {
+        std::string name = std::string(s->common.snapshot_save_name);
+        name += ".fini";
+        virt_machine_serialize(s, name.c_str());
+    }
+    sigfile.close();
 
     /* XXX: stop all */
     for (int i = 0; i < s->ncpus; ++i) {
         riscv_cpu_end(s->cpu_state[i]);
     }
 
     phys_mem_map_end(s->mem_map);
     free(s);
 }
 
@@ -1456,27 +1610,35 @@ static inline void serialize_devices(RISCVMachine *m, const char *dump_base) {
     FILE *fd = fopen(dump_name, "w");
     if (!fd) {
         err(-3, "opening %s for serialization", dump_name);
     }
     json_write(devs_json, fd, 0);
     fclose(fd);
     json_free(devs_json);
 }
 
 void virt_machine_serialize(RISCVMachine *m, const char *dump_name) {
-    RISCVCPUState *s = m->cpu_state[0];  // FIXME: MULTICORE
+    fprintf(dromajo_stderr, "creating a new boot rom\n");
+    for (int i = m->mem_map->n_phys_mem_range - 1; i >= 0; --i) {
+        PhysMemoryRange *pr = &m->mem_map->phys_mem_range[i];
 
-    vm_error("plic: %x %x timecmp=%llx\n", m->plic_pending_irq, m->plic_served_irq, (unsigned long long)s->timecmp);
-
-    assert(m->ncpus == 1);  // FIXME: riscv_cpu_serialize must be patched for multicore
-    riscv_cpu_serialize(s, dump_name, m->clint_base_addr);
-    serialize_devices(m, dump_name);
+        if (pr->is_ram && pr->addr == ROM_BASE_ADDR) {
+            char *boot_name = (char *)alloca(strlen(dump_name) + 64);
+            sprintf(boot_name, "%s.bootram", dump_name);
+            create_boot_rom(m, boot_name, m->clint_base_addr);
+        }
+        else if (pr->is_ram && pr->addr == m->ram_base_addr) {
+            char *main_name = (char *)alloca(strlen(dump_name) + 64);
+            sprintf(main_name, "%s.mainram", dump_name);
+            serialize_memory(pr->phys_mem, pr->size, main_name);
+        }
+    }
 }
 
 static inline void deserialize_plic(RISCVMachine *m, JSONValue plic_device) {
     // PLIC priority
     JSONValue val = json_object_get(plic_device, "plic_priority");
     for (int irq = 0; irq < PLIC_NUM_SOURCES + 1; ++irq) {
         JSONValue a           = json_array_get(val, irq);
         JSONValue j           = json_object_get(a, "irq");
         m->plic_priority[irq] = (uint32_t)json_get_int64(j);
     }
@@ -1530,25 +1692,34 @@ static inline void deserialize_devices(RISCVMachine *m, const char *dump_base) {
         char dev_name[5];
         snprintf(dev_name, 5, "vio%d", i);
         dev_cfg = json_object_get(devs_json, dev_name);
         virtio_device_deserialize(m->virtio_devices[i], dev_cfg);
     }
     json_free(devs_json);
     free(buf);
 }
 
 void virt_machine_deserialize(RISCVMachine *m, const char *dump_name) {
-    RISCVCPUState *s = m->cpu_state[0];  // FIXME: MULTICORE
+    for (int i = m->mem_map->n_phys_mem_range - 1; i >= 0; --i) {
+        PhysMemoryRange *pr = &m->mem_map->phys_mem_range[i];
 
-    assert(m->ncpus == 1);  // FIXME: riscv_cpu_serialize must be patched for multicore
-    riscv_cpu_deserialize(s, dump_name);
-    deserialize_devices(m, dump_name);
+        if (pr->is_ram && pr->addr == ROM_BASE_ADDR) {
+            char *boot_name = (char *)alloca(strlen(dump_name) + 64);
+            sprintf(boot_name, "%s.bootram", dump_name);
+            deserialize_memory(pr->phys_mem, pr->size, boot_name);
+        }
+        else if (pr->is_ram && pr->addr == m->ram_base_addr) {
+            char *main_name = (char *)alloca(strlen(dump_name) + 64);
+            sprintf(main_name, "%s.mainram", dump_name);
+            deserialize_memory(pr->phys_mem, pr->size, main_name);
+        }
+    }
 }
 
 int virt_machine_get_sleep_duration(RISCVMachine *m, int hartid, int ms_delay) {
     RISCVCPUState *s = m->cpu_state[hartid];
     int64_t        ms_delay1;
 
     /* wait for an event: the only asynchronous event is the RTC timer */
     if (!(riscv_cpu_get_mip(s) & MIP_MTIP) && rtc_get_time(m) > 0) {
         ms_delay1 = s->timecmp - rtc_get_time(m);
         if (ms_delay1 <= 0) {
@@ -1561,20 +1732,30 @@ int virt_machine_get_sleep_duration(RISCVMachine *m, int hartid, int ms_delay) {
                 ms_delay = ms_delay1;
         }
     }
 
     if (!riscv_cpu_get_power_down(s))
         ms_delay = 0;
 
     return ms_delay;
 }
 
+void virt_machine_tick(RISCVMachine *m, int n_cycles) {
+    for (int i = m->mem_map->n_phys_mem_range - 1; i >= 0; --i) {
+        PhysMemoryRange *pr = &m->mem_map->phys_mem_range[i];
+            
+        if (!pr->is_ram) {
+            pr->tick_func(pr->opaque, n_cycles);
+        }           
+    }
+}
+
 uint64_t virt_machine_get_pc(RISCVMachine *s, int hartid) { return riscv_get_pc(s->cpu_state[hartid]); }
 
 uint64_t virt_machine_get_reg(RISCVMachine *s, int hartid, int rn) { return riscv_get_reg(s->cpu_state[hartid], rn); }
 
 uint64_t virt_machine_get_fpreg(RISCVMachine *s, int hartid, int rn) { return riscv_get_fpreg(s->cpu_state[hartid], rn); }
 
 const char *virt_machine_get_name(void) { return "riscv64"; }
 
 void vm_send_key_event(RISCVMachine *s, BOOL is_down, uint16_t key_code) {
     if (s->keyboard_dev) {
diff --git a/src/virtio.cpp b/src/virtio.cpp
index 33c26ac..bd96133 100644
--- a/src/virtio.cpp
+++ b/src/virtio.cpp
@@ -272,34 +272,38 @@ static void virtio_init(VIRTIODevice *s, VIRTIOBusDef *bus, uint32_t device_id,
         virtio_add_pci_capability(s, 4, bar_num, VIRTIO_PCI_CONFIG_OFFSET, 0x1000, 0); /* config */
         virtio_add_pci_capability(s, 2, bar_num, VIRTIO_PCI_NOTIFY_OFFSET, 0x1000, 0); /* notify */
 
         s->get_ram_ptr = virtio_pci_get_ram_ptr;
         s->irq         = pci_device_get_irq(s->pci_dev, 0);
         s->mem_map     = pci_device_get_mem_map(s->pci_dev);
         s->mem_range   = cpu_register_device(s->mem_map,
                                            0,
                                            0x4000,
                                            s,
+                                           DefaultInitFunc,
                                            virtio_pci_read,
                                            virtio_pci_write,
+                                           DefaultTickFunc,
                                            DEVIO_SIZE8 | DEVIO_SIZE16 | DEVIO_SIZE32 | DEVIO_DISABLED);
         pci_register_bar(s->pci_dev, bar_num, 0x4000, PCI_ADDRESS_SPACE_MEM, s, virtio_pci_bar_set);
     } else {
         /* MMIO case */
         s->mem_map     = bus->mem_map;
         s->irq         = bus->irq;
         s->mem_range   = cpu_register_device(s->mem_map,
                                            bus->addr,
                                            VIRTIO_PAGE_SIZE,
                                            s,
+                                           DefaultInitFunc,
                                            virtio_mmio_read,
                                            virtio_mmio_write,
+                                           DefaultTickFunc,
                                            DEVIO_SIZE8 | DEVIO_SIZE16 | DEVIO_SIZE32);
         s->get_ram_ptr = virtio_mmio_get_ram_ptr;
     }
 
     s->device_id         = device_id;
     s->vendor_id         = 0xffff;
     s->config_space_size = config_space_size;
     s->device_recv       = device_recv;
     virtio_reset(s);
 }
-- 
2.18.4

